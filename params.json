{
  "name": "cobj",
  "tagline": "cobj allows to implement interface based polymorphism in plain c in a simple, efficient and typesafe way",
  "body": "# cobj\r\n\r\ncobj allows to implement interface based polymorphism in plain C. It's a pattern, and a generator, based on the preprocessor.\r\n\r\n## Features\r\n\r\ncobj enables developers to use a simple and comfortable way to implement polymorphism, based on interfaces and classes.\r\n\r\n## cobj is no runtime\r\nThis means that cobj don't care about allocation, managing lifetime, serialization or error-handling.\r\nIt's just a way to call methods on an object. In opposite to other implementations, which often require that objects are on the heap, maybe including garbage collection or reference counting, in cobj you have total control over your objects.\r\n\r\n## cobj uses only the preprocessor\r\nThere is no external code-generator, build step or any other tool needed beside\r\nthe C compiler. The cobj generator is heavily based on the x-macro technique, to\r\ngenerate the code needed.\r\n\r\n## cobj wants to be easy, safe and natural to use\r\nEasy: Once you get the macros done (there will be templates provided), everything beside the\r\nimplementation is created by the cobj generator (some .h files).\r\n\r\nNatural: It generates global functions for each interface, so you don't mess around\r\nwith calling functions out of a struct of function pointers.\r\n\r\nSafe: Everything is strong typed, so you don't have to cast anywhere to use cobj.\r\n\r\n# Entities\r\n\r\ncobj basically defines this kind of entities:\r\n\r\n## Descriptors\r\nA descriptor is a global variable, which describes an interface,\r\nor a class. Because they are const, they are normally compiled into program memory.\r\nSo they use no ram.\r\n\r\n## Interfaces\r\nAn interface represents a named set of method prototypes, without implementation.\r\n\r\n## Classes\r\n\r\nA class consists of the following parts:\r\n\r\n* Implemented interfaces: A class is the entity implementing one ore more interfaces.\r\n* Variables: A class may declare variables, which represent the private state of the object.\r\n* Arguments for the initializer: To avoid that a \"private interface\" needs to be\r\ndefined just for the initialization of an object, cobj classes can define a single\r\ninitialization method.\r\n\r\n## Objects\r\n\r\nAn object is an instance of a class. It's basically a struct, consisting of a pointer to the class-descriptor, and every declared variable.\r\n\r\n## References\r\nBeside the initializer, no method can be directly called on an object. This is what\r\nreferences are for. A reference is initialized by calling a \"queryinterface\" method\r\nfor a specific interface, providing a pointer to an object.\r\n\r\nOnce you got a reference, you may call interface-methods, pass them around, and\r\ndo whatever you like.\r\n\r\n# Some code\r\nI'm sure you want to see some code, right? I'll show you how to declare interfaces\r\nand classes afterwards. This is how to use cobj once that is done:\r\n\r\n```C\r\n\r\n// We have declared an interface named \"gpio_pin\", declaring a method:\r\n// \tbool read_value()\r\n// We have class named \"hw_gpio_pin\" implementing this interface\r\n//\tThe \"hw_gpio_pin\" has an initializer \"int pin_nr\"\r\n\r\nvoid foo()\r\n{\r\n\t// create a hw_gpio_pin on the stack:\r\n\thw_gpio_pin pinObject;\r\n\r\n\t// call the initializer for pin #13\r\n\thw_gpio_pin_initialize(&pinObject, 13);\r\n\r\n\t// to call the \"get_value\" function of the \"gpio_pin\" interface, we have to\r\n\t// query for a reference:\r\n\r\n\tgpio_pin pinReference;\r\n\tgpio_pin_queryreference(pinObject.object, &pinReference);\r\n\r\n\tbar(pinReference);\r\n}\r\n\r\nvoid bar(gpio_pin pin)\r\n{\r\n\t// read the pin value:\r\n\tbool val = gpio_pin_get_value(pin);\r\n}\r\n\r\n```\r\n\r\n# What happens at runtime?\r\n\r\nI'll take the previous example to show you want's going on in cobj.\r\n\r\n## For the gpio_pin interface:\r\nOnce you have the \"gpio_pin\", you have the following code be generated in\r\nevery file which does a #include \"gpio_pin.h\":\r\n\r\n```C\r\n// this is the struct of function-pointers for the interface, _mt stands for\r\n// \"methodtable\"\r\ntypedef struct {\r\n   bool (* get_value)(cobj_object * self)\r\n} gpio_pin_mt;\r\n\r\n// this is the strong typed reference struct for any gpio-pin. Because References\r\n// are used very often, there is no _reference suffix. A reference is an instance\r\n// of an interface, so I find it better this way.\r\ntypedef struct {\r\n gpio_pin_mt * mt;\r\n cobj_object * object;\r\n} gpio_pin;\r\n\r\n// this is the declaration to the global descriptor\r\nextern const cobj_interface_descriptor * const gpio_pin_descriptor;\r\n\r\n// this is the declaration to the queryinterface method\r\nbool gpio_pin_queryinterface(cobj_object * object, gpio_pin * reference);\r\n\r\n// now the declarations of the callable methods follow, we have just one:\r\nbool gpio_pin_get_value(const gpio_pin * reference);\r\n\r\n```\r\n\r\n## For the hw_gpio_pin class:\r\nThe following code is generated into files including hw_gpio_pin.h:\r\n\r\n```C\r\n\r\n// This is the struct for the object's data. The class_desriptor is always the\r\n// first field in this structure. To allow inline allocation of an object,\r\n// the size of the object must be known to the compiler, this also includes\r\n// padding and alignment, so it's not wise to use char[sum of sizeof all variables].\r\n// Because of this, the variables are generated as they are into a struct,\r\n// but with symbolic names. So we know that this class as two integer fields\r\n// for it's variables. Why don't allow C unnamed struct members in such a case...\r\ntypedef union {\r\n struct {\r\n  const cobj_class_descriptor * class_desriptor;\r\n  struct {\r\n\t\tint private_0;\r\n\t\tint private_1;\r\n  } class_data;\r\n } private_data;\r\n cobj_object object;\r\n} hw_gpio_pin;\r\n\r\n// declare the descriptor for the class:\r\nextern const cobj_class_descriptor * const hw_gpio_pin_descriptor;\r\n\r\n// declare the initializer for the class:\r\nvoid hw_gpio_pin_initialize(hw_gpio_pin * self, int pin_nr);\r\n\r\n```\r\n\r\nTo see the whole picture, you need to know the implementation of initialize,\r\nqueryinterface and the callable methods:\r\n\r\nThe first thing: You see some declarations in gpio_pin.h. But wait: This is just\r\na .h file, where is the implementation?\r\n\r\nIn every project there is a single file named \"interface_registry.c\". Technically\r\nit don't have to be in a single file. You may split it up in several files. As long\r\nas every used interface is in exact one registry file, it's ok:\r\n\r\n```C\r\n\r\n// a registry only enables registry mode, and then includes the .h files\r\n// of all interfaces\r\n#define COBJ_INTERFACE_REGISTRY_MODE\r\n#include \"gpio_pin.h\"\r\n#undef  COBJ_INTERFACE_REGISTRY_MODE\r\n\r\n// this causes the following code to be generated:\r\n/////////////////////////////////////////////////////\r\n\r\n// queryinterface method\r\nbool gpio_pin_queryinterface(cobj_object * object, gpio_pin * reference) {\r\n  cobj_mt mt = object->class_descriptor->queryinterface(gpio_pin_descriptor);\r\n  if(!mt){\r\n   return false;\r\n  }\r\n\r\n  reference->mt = (gpio_pin_mt*)mt;\r\n  reference->object = object;\r\n\r\n  return true;\r\n }\r\n\r\n// callable methods (we have just one):\r\nbool gpio_pin_get_value(const gpio_pin * reference )\r\n{\r\n\treturn reference->mt->get_value(reference->object);\r\n}\r\n\r\n```\r\nThe last thing we need to know for the basic understanding, is the hw_gpio_pin.c\r\nfile:\r\n\r\n```C\r\n\r\n// this code I have to write\r\n#define COBJ_IMPLEMENTATION_FILE\r\n\r\n#include \"hw_gpio_pin.h\"\t// technically all code below is generated here!\r\n\r\n// this is the initialize method. It's static as every other _impl method!\r\nstatic bool initialize_impl(hw_gpio_pin_impl * self, int pin_nr)\r\n{\r\n\t// I can do what I want, just initialize some register addresses\r\n\tself->port_address = 0x7FFF1000 + (pin_nr << 5) * 0x100;\r\n\tself->port_mask = 1 << (pin_nr & 0x20);\r\n\treturn true;\r\n}\r\n\r\n// this is our implementation of the get_value method:\r\nstatic bool gpio_pin_get_value_impl(hw_gpio_pin_impl * self)\r\n{\r\n\t// access some gpio register here to read the value\r\n\tvolatile int * pvr = self->port_address + 0x10;\r\n\treturn (* pvr && self->port_mask) != 0;\r\n}\r\n\r\n// this code is being generated:\r\n/////////////////////////////////////////////////////\r\n\r\n// our _impl object structure, with the real names of the variables:\r\ntypedef struct {\r\n  cobj_class_descriptor * class_desriptor;\r\n  int portNr;\r\n\tint portMask;\r\n } hw_gpio_pin_impl;\r\n\r\n// forward declarations to the _impl functions:\r\nstatic bool gpio_pin_get_value_impl(hw_gpio_pin_impl* self);\r\n\r\n// forward declarations to the _thunk functions:\r\nstatic bool gpio_pin_get_value_thunk(cobj_object* self )\r\n\r\n// implementations of the _thunk functions (they basically perform the cast)\r\nstatic bool gpio_pin_get_value_thunk(cobj_object * self ) {\r\n\treturn gpio_pin_get_value_impl((hw_gpio_pin_impl*)self );\r\n}\r\n\r\n// a _mt struct for each implemented interface:\r\nstatic const gpio_pin_mt hw_gpio_pin_gpio_pin_mt =\r\n  .get_value = &gpio_pin_get_value_thunk,\r\n };\r\n\r\n// forward declaration to the initialize_impl function:\r\nstatic bool initialize_impl(hw_gpio_pin_impl * self, int portNr);\r\n\r\n// implementation of the initialize function:\r\nbool hw_gpio_pin_initialize(hw_gpio_pin * self, int portNr)\r\n{\r\n  self->private_data.class_desriptor = hw_gpio_pin_descriptor;\r\n  return initialize_impl((hw_gpio_pin_impl*)self, portNr);\r\n}\r\n\r\n// forward declaration of queryinterface:\r\nstatic cobj_mt queryinterface(const cobj_interface_descriptor * interface);\r\n\r\n// implementation of queryinterface:\r\nstatic cobj_mt queryinterface(const cobj_interface_descriptor * interface){\r\n\tif(interface == gpio_pin_descriptor) return (cobj_mt)(&hw_gpio_pin_gpio_pin_mt);\r\n  return (cobj_mt*)0;\r\n }\r\n\r\n// and finally, the descriptor:\r\nstatic const cobj_class_descriptor hw_gpio_pin_descriptor_instance = {\r\n  .class_name = \"hw_gpio_pin\",\r\n  .queryinterface = &queryinterface\r\n };\r\n\r\n const cobj_class_descriptor * const hw_gpio_pin_descriptor = &hw_gpio_pin_descriptor_instance;\r\n\r\n```\r\n\r\n\r\nIn the next chapter I'll show you how to declare this things!\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}